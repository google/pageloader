part of 'typing.dart';

// **************************************************************************
// PageObjectGenerator
// **************************************************************************

// ignore_for_file: private_collision_in_mixin_application
class $PageForTextAreaTypingText extends PageForTextAreaTypingText
    with $$PageForTextAreaTypingText {
  PageLoaderElement $__root__;
  $PageForTextAreaTypingText.create(PageLoaderElement currentContext)
      : $__root__ = currentContext {
    $__root__.addCheckers([]);
  }
  factory $PageForTextAreaTypingText.lookup(PageLoaderSource source) =>
      throw "'lookup' constructor for class "
      "PageForTextAreaTypingText is not generated and can only be used on Page Object "
      "classes that have @CheckTag annotation.";
  static String get tagName =>
      throw '"tagName" is not defined by Page Object "PageForTextAreaTypingText". Requires @CheckTag annotation in order for "tagName" to be generated.';
  String toStringDeep() =>
      'PageForTextAreaTypingText\n\n${$__root__.toStringDeep()}';
}

class $$PageForTextAreaTypingText {
  PageLoaderElement $__root__;
  PageLoaderMouse __mouse__;
  PageLoaderElement get $root => $__root__;
  PageLoaderElement get textArea {
    for (final __listener in $__root__.listeners) {
      __listener.startPageObjectMethod('PageForTextAreaTypingText', 'textArea');
    }
    final element = $__root__.createElement(const ById('textarea'), [], []);
    final returnMe = element;
    for (final __listener in $__root__.listeners) {
      __listener.endPageObjectMethod('PageForTextAreaTypingText', 'textArea');
    }
    return returnMe;
  }
}

// ignore_for_file: private_collision_in_mixin_application
class $PageForTypingTests extends PageForTypingTests with $$PageForTypingTests {
  PageLoaderElement $__root__;
  $PageForTypingTests.create(PageLoaderElement currentContext)
      : $__root__ = currentContext {
    $__root__.addCheckers([]);
  }
  factory $PageForTypingTests.lookup(PageLoaderSource source) =>
      throw "'lookup' constructor for class "
      "PageForTypingTests is not generated and can only be used on Page Object "
      "classes that have @CheckTag annotation.";
  static String get tagName =>
      throw '"tagName" is not defined by Page Object "PageForTypingTests". Requires @CheckTag annotation in order for "tagName" to be generated.';
  String toStringDeep() => 'PageForTypingTests\n\n${$__root__.toStringDeep()}';
}

class $$PageForTypingTests {
  PageLoaderElement $__root__;
  PageLoaderMouse __mouse__;
  PageLoaderElement get $root => $__root__;
  PageLoaderElement get text {
    for (final __listener in $__root__.listeners) {
      __listener.startPageObjectMethod('PageForTypingTests', 'text');
    }
    final element = $__root__.createElement(const ById('text'), [], []);
    final returnMe = element;
    for (final __listener in $__root__.listeners) {
      __listener.endPageObjectMethod('PageForTypingTests', 'text');
    }
    return returnMe;
  }
}

// ignore_for_file: private_collision_in_mixin_application
class $PageForTypingTestsWithFocusAndBlur
    extends PageForTypingTestsWithFocusAndBlur
    with $$PageForTypingTestsWithFocusAndBlur {
  PageLoaderElement $__root__;
  $PageForTypingTestsWithFocusAndBlur.create(PageLoaderElement currentContext)
      : $__root__ = currentContext {
    $__root__.addCheckers([]);
  }
  factory $PageForTypingTestsWithFocusAndBlur.lookup(PageLoaderSource source) =>
      throw "'lookup' constructor for class "
      "PageForTypingTestsWithFocusAndBlur is not generated and can only be used on Page Object "
      "classes that have @CheckTag annotation.";
  static String get tagName =>
      throw '"tagName" is not defined by Page Object "PageForTypingTestsWithFocusAndBlur". Requires @CheckTag annotation in order for "tagName" to be generated.';
  int get focusCount {
    for (final __listener in $__root__.listeners) {
      __listener.startPageObjectMethod(
          'PageForTypingTestsWithFocusAndBlur', 'focusCount');
    }
    final returnMe = super.focusCount;
    for (final __listener in $__root__.listeners) {
      __listener.endPageObjectMethod(
          'PageForTypingTestsWithFocusAndBlur', 'focusCount');
    }
    return returnMe;
  }

  int get blurCount {
    for (final __listener in $__root__.listeners) {
      __listener.startPageObjectMethod(
          'PageForTypingTestsWithFocusAndBlur', 'blurCount');
    }
    final returnMe = super.blurCount;
    for (final __listener in $__root__.listeners) {
      __listener.endPageObjectMethod(
          'PageForTypingTestsWithFocusAndBlur', 'blurCount');
    }
    return returnMe;
  }

  String toStringDeep() =>
      'PageForTypingTestsWithFocusAndBlur\n\n${$__root__.toStringDeep()}';
}

class $$PageForTypingTestsWithFocusAndBlur {
  PageLoaderElement $__root__;
  PageLoaderMouse __mouse__;
  PageLoaderElement get $root => $__root__;
  PageLoaderElement get text {
    for (final __listener in $__root__.listeners) {
      __listener.startPageObjectMethod(
          'PageForTypingTestsWithFocusAndBlur', 'text');
    }
    final element =
        $__root__.createElement(const ById('text-with-focus-and-blur'), [], []);
    final returnMe = element;
    for (final __listener in $__root__.listeners) {
      __listener.endPageObjectMethod(
          'PageForTypingTestsWithFocusAndBlur', 'text');
    }
    return returnMe;
  }

  PageLoaderElement get _focusCount {
    for (final __listener in $__root__.listeners) {
      __listener.startPageObjectMethod(
          'PageForTypingTestsWithFocusAndBlur', '_focusCount');
    }
    final element = $__root__.createElement(
        const ById('text-with-focus-and-blur-focus-count'), [], []);
    final returnMe = element;
    for (final __listener in $__root__.listeners) {
      __listener.endPageObjectMethod(
          'PageForTypingTestsWithFocusAndBlur', '_focusCount');
    }
    return returnMe;
  }

  PageLoaderElement get _blurCount {
    for (final __listener in $__root__.listeners) {
      __listener.startPageObjectMethod(
          'PageForTypingTestsWithFocusAndBlur', '_blurCount');
    }
    final element = $__root__.createElement(
        const ById('text-with-focus-and-blur-blur-count'), [], []);
    final returnMe = element;
    for (final __listener in $__root__.listeners) {
      __listener.endPageObjectMethod(
          'PageForTypingTestsWithFocusAndBlur', '_blurCount');
    }
    return returnMe;
  }
}

// ignore_for_file: private_collision_in_mixin_application
class $KeyboardListenerPO extends KeyboardListenerPO with $$KeyboardListenerPO {
  PageLoaderElement $__root__;
  $KeyboardListenerPO.create(PageLoaderElement currentContext)
      : $__root__ = currentContext {
    $__root__.addCheckers([]);
  }
  factory $KeyboardListenerPO.lookup(PageLoaderSource source) =>
      throw "'lookup' constructor for class "
      "KeyboardListenerPO is not generated and can only be used on Page Object "
      "classes that have @CheckTag annotation.";
  static String get tagName =>
      throw '"tagName" is not defined by Page Object "KeyboardListenerPO". Requires @CheckTag annotation in order for "tagName" to be generated.';
  String toStringDeep() => 'KeyboardListenerPO\n\n${$__root__.toStringDeep()}';
}

class $$KeyboardListenerPO {
  PageLoaderElement $__root__;
  PageLoaderMouse __mouse__;
  PageLoaderElement get $root => $__root__;
  PageLoaderElement get listener {
    for (final __listener in $__root__.listeners) {
      __listener.startPageObjectMethod('KeyboardListenerPO', 'listener');
    }
    final element =
        $__root__.createElement(const ById('keyboard-listener'), [], []);
    final returnMe = element;
    for (final __listener in $__root__.listeners) {
      __listener.endPageObjectMethod('KeyboardListenerPO', 'listener');
    }
    return returnMe;
  }
}
